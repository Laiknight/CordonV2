@page "/"

<PageTitle>Home</PageTitle>

@if(!dataUploaded && !dataUploading && string.IsNullOrEmpty(ErrorMessage))
{
    <MudText Typo="Typo.h3" Style="text-align: center;" GutterBottom="true">FILE UPLOAD</MudText>
    <MudGrid Justify="Justify.Center">
        <MudItem>
            <MudFileUpload T="IBrowserFile" Accept=".csv" FilesChanged="FileUploaded">
                <ActivatorContent>
                    <MudButton Variant="Variant.Filled"
                            Color="Color.Primary"
                            StartIcon="@Icons.Material.Filled.CloudUpload">
                        Upload Files
                    </MudButton>
                </ActivatorContent>
            </MudFileUpload>
        </MudItem>
    </MudGrid>
} else if (dataUploading)
{
    <MudGrid Justify="Justify.Center" Class="object-position: center;">
        <MudItem>
            <MudProgressCircular Color="Color.Primary" Style="height:70px;width:70px;" Indeterminate="true" Class="object-center"/>
        </MudItem>
    </MudGrid>
} else if (!string.IsNullOrEmpty(ErrorMessage))
{
    <MudGrid Justify="Justify.Center">
        <MudFileUpload T="IBrowserFile" Accept=".csv" FilesChanged="FileUploaded">
            <ActivatorContent>
                <MudButton Variant="Variant.Filled"
                        Color="Color.Primary"
                        StartIcon="@Icons.Material.Filled.CloudUpload">
                    Upload Files
                </MudButton>
            </ActivatorContent>
        </MudFileUpload>
        <MudText Typo="Typo.h6" Style="text-align: center;" GutterBottom="true">@ErrorMessage</MudText>
    </MudGrid>
} else if (dataUploaded)
{
    <MudGrid>
        <MudItem xs="4" >
            <MudChart ChartType="ChartType.Bar" ChartSeries="@MAD" XAxisLabels="@MADX.ToArray()" ChartOptions="@chartOptions" Width="100%" Height="350px">
                <CustomGraphics>
                    <style>
                        .heavy { font: bold 30px Helvetica; }
                    </style>
                    <text x="80" y="35" class="heavy">Most Accessed Doors</text>
                </CustomGraphics>
            </MudChart>
        </MudItem>

        <MudItem xs="4" >
            <MudChart ChartType="ChartType.Bar" ChartSeries="@MAU" XAxisLabels="@MAUX.ToArray()" ChartOptions="@chartOptions" AxisChartOptions="@axisOptions" Width="100%" Height="350px">
                <CustomGraphics>
                    <style>
                        .heavy { font: bold 30px Helvetica; }
                    </style>
                    <text x="80" y="35" class="heavy">Most Active Users</text>
                </CustomGraphics>
            </MudChart>
        </MudItem>

        <MudItem xs="4" >
            <MudChart ChartType="ChartType.Bar" ChartSeries="@DA" XAxisLabels="@DAX.ToArray()" ChartOptions="@chartOptions" AxisChartOptions="@axisOptions" Width="100%" Height="350px">
                <CustomGraphics>
                    <style>
                        .heavy { font: bold 30px Helvetica; }
                    </style>
                    <text x="80" y="35" class="heavy">Daily Activity</text>
                </CustomGraphics>
            </MudChart>
        </MudItem>

        <MudItem xs="4" >
            <MudChart ChartType="ChartType.StackedBar" ChartSeries="@UDE" XAxisLabels="@UDEX.ToArray()" ChartOptions="@chartOptions" AxisChartOptions="@axisOptions" Width="100%" Height="350px">
                <CustomGraphics>
                    <style>
                        .heavy { font: bold 30px Helvetica; }
                    </style>
                    <text x="80" y="35" class="heavy">Unique Daily Entries</text>
                </CustomGraphics>
            </MudChart>
        </MudItem>

        <MudItem xs="4" >
            <MudChart ChartType="ChartType.Bar" ChartSeries="@LIT" XAxisLabels="@LITX.ToArray()" ChartOptions="@chartOptions" AxisChartOptions="@axisOptions" Width="100%" Height="350px">
                <CustomGraphics>
                    <style>
                        .heavy { font: bold 30px Helvetica; }
                    </style>
                    <text x="80" y="35" class="heavy">Longest Inactivity Times</text>
                </CustomGraphics>
            </MudChart>
        </MudItem>

        <MudItem xs="4" >
            <MudChart ChartType="ChartType.Bar" ChartSeries="@AE" XAxisLabels="@AEX.ToArray()" ChartOptions="@chartOptions"AxisChartOptions="@axisOptions"  Width="100%" Height="350px">
                <CustomGraphics>
                    <style>
                        .heavy { font: bold 30px Helvetica; }
                    </style>
                    <text x="80" y="35" class="heavy">Abnormal Entries</text>
                </CustomGraphics>
            </MudChart>
        </MudItem>
    </MudGrid>
}

@code {
    public string FileName { get; set; } = "";
    public long FileSize { get; set; }
    public string FileType { get; set; } = "";
    public DateTimeOffset LastModified { get; set; }
    public string ErrorMessage { get; set; } = "";
    public bool dataUploaded { get; set; } = false;
    public bool dataUploading { get; set; } = false;
    public int topNum = 10;

    ChartOptions chartOptions = new ChartOptions()
    {
        ShowLegend = false,
        XAxisLines = true,
        YAxisLines = true,
        ShowToolTips = false,
    };

    AxisChartOptions axisOptions = new AxisChartOptions()
    {
        MatchBoundsToSize = true,
    };

    //Most Accessed Doors
    public List<ChartSeries> MAD { get; set; } = new List<ChartSeries>();
    public List<string> MADX { get; set; } = new List<string>();

    //Most Active Users
    public List<ChartSeries> MAU { get; set; } = new List<ChartSeries>();
    public List<string> MAUX { get; set; } = new List<string>();

    //Daily Activity
    public List<ChartSeries> DA { get; set; } = new List<ChartSeries>();
    public List<string> DAX { get; set; } = new List<string>();
    
    //Unique Daily Entries
    public List<ChartSeries> UDE { get; set; } = new List<ChartSeries>();
    public List<string> UDEX { get; set; } = new List<string>();

    //Longest Inactivity Times
    public List<ChartSeries> LIT { get; set; } = new List<ChartSeries>();
    public List<string> LITX { get; set; } = new List<string>();
        
    //Abnormal Entries
    public List<ChartSeries> AE { get; set; } = new List<ChartSeries>();
    public List<string> AEX { get; set; } = new List<string>();

    StreamReader? reader;
    List<ReaderEvent> readerEvents = new List<ReaderEvent>();

    const int MAX_FILESIZE = 5120000;

    public async Task FileUploaded(IBrowserFile file)
    {
        var browserFile = file;
        dataUploading = true;

        if (browserFile != null)
        {
            FileSize = browserFile.Size;
            FileType = browserFile.ContentType;
            FileName = browserFile.Name;
            LastModified = browserFile.LastModified;

            try
            {
                ErrorMessage = "";
                var fileStream = browserFile.OpenReadStream(MAX_FILESIZE);

                var randomFile = Path.GetTempFileName();
                var extension = Path.GetExtension(browserFile.Name);
                var targetFilePath = Path.ChangeExtension(randomFile, extension);

                using (var destinationStream = new FileStream(targetFilePath, FileMode.Create))
                {
                    await fileStream.CopyToAsync(destinationStream);
                }

                reader = new StreamReader(targetFilePath);
                await ReadFile();
                reader.Close();

                dataUploaded = true;
                dataUploading = false;
            }
            catch (Exception exception)
            {
                ErrorMessage = exception.Message;
                dataUploading = false;
            }
        }
    }

    async Task ReadFile()
    {
        if(reader != null)
        {
            var line = await reader.ReadLineAsync();
            line = await reader.ReadLineAsync();
            while (line != null)
            {
                var fields = line.Split(',');

                if (fields.Length == 6)
                {
                    var readerEvent = new ReaderEvent(fields[0], fields[1], fields[2], fields[3], fields[4], fields[5]);
                    readerEvents.Add(readerEvent);
                }
                line = await reader.ReadLineAsync();
            }
        }
        if (readerEvents.Count > 0)
        {
            SetUpData();
        }
        else
        {
            ErrorMessage = "No data found in the file.";
        }
    }

    void SetUpData()
    {
        MostAccessedDoors();
        MostActiveUsers();
        DailyActivity();
        UniqueDailyEntries();
        LongestInactivityTimes();
        AbnormalEntries();
    }

    void MostAccessedDoors()
    {
        Dictionary<string, int> numAccessed = new Dictionary<string, int>();

        foreach (var readerEvent in readerEvents)
        {
            if (numAccessed.ContainsKey(readerEvent.uniqueID))
            {
                numAccessed[readerEvent.uniqueID]++;
            }
            else
            {
                numAccessed.Add(readerEvent.uniqueID, 1);
            }
        }

        var sortedNumAccessed = numAccessed.OrderByDescending(x => x.Value).ToList();
        MADX = new List<string>();
        double[] data = new double[topNum];
        for (int i = 0; i < sortedNumAccessed.Count; i++)
        {
            if (i < topNum)
            {
                MADX.Add(sortedNumAccessed[i].Key);
                data[i] = Convert.ToDouble(sortedNumAccessed[i].Value);
            }
        }
        MAD.Add(new ChartSeries() { Name = "Most Accessed Doors", Data = data });
    }

    void MostActiveUsers()
    {
        Dictionary<string, int> numAccessed = new Dictionary<string, int>();

        foreach (var readerEvent in readerEvents)
        {
            if (numAccessed.ContainsKey(readerEvent.idHash))
            {
                numAccessed[readerEvent.idHash]++;
            }
            else
            {
                numAccessed.Add(readerEvent.idHash, 1);
            }
        }

        var sortedNumAccessed = numAccessed.OrderByDescending(x => x.Value).ToList();
        MAUX = new List<string>();
        double[] data = new double[topNum];
        for (int i = 0; i < sortedNumAccessed.Count; i++)
        {
            if (i < topNum)
            {
                MAUX.Add(sortedNumAccessed[i].Key);
                data[i] = Convert.ToDouble(sortedNumAccessed[i].Value);
            }
        }
        MAU.Add(new ChartSeries() { Name = "Most Active Users", Data = data });
    }

    void DailyActivity()
    {
        Dictionary<string, int> numAccessed = new Dictionary<string, int>();
        Dictionary<string, List<DateTime>> timesAccessed = new Dictionary<string, List<DateTime>>();

        foreach (var readerEvent in readerEvents)
        {
            var date = DateTime.Parse(readerEvent.eventTime.Substring(0,readerEvent.eventTime.IndexOf('T')));
            if (numAccessed.ContainsKey(date.DayOfWeek.ToString()))
            {
                numAccessed[date.DayOfWeek.ToString()]++;
                if(!timesAccessed[date.DayOfWeek.ToString()].Contains(date))
                    timesAccessed[date.DayOfWeek.ToString()].Add(date);
            }
            else
            {
                numAccessed.Add(date.DayOfWeek.ToString(), 1);
                timesAccessed.Add(date.DayOfWeek.ToString(), new List<DateTime>() { date });
            }
        }

        DAX = new List<string>{  "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
        double[] data = new double[DAX.Count];
        for (int j = 0; j < DAX.Count; j++)
        {
            data[j] =  Convert.ToDouble(numAccessed[DAX[j]])/Convert.ToDouble(timesAccessed[DAX[j]].Count);
        }
        DA.Add(new ChartSeries() { Name = "Average", Data = data } );
    }

    //Stacked bar graph of top 5 doors with the most unique entries per day
    //Current issue: The data is not being added to the chart correctly
    //Potential Reason: When I average out the number of accesses for the door per specified day it might be messing up. Please look into this.
    void UniqueDailyEntries()
    {
        //string 1 = date, string 2 = door, string 3 = idHashs
        Dictionary<string, Dictionary<string, List<string>>> numAccessed = new Dictionary<string, Dictionary<string, List<string>>>();

        foreach(var readerEvent in readerEvents)
        {
            var date = DateTime.Parse(readerEvent.eventTime.Substring(0, readerEvent.eventTime.IndexOf('T')));
            if (numAccessed.ContainsKey(date.ToString("yyyy-MM-dd")))
            {
                if (numAccessed[date.ToString("yyyy-MM-dd")].ContainsKey(readerEvent.uniqueID))
                {
                    if(!numAccessed[date.ToString("yyyy-MM-dd")][readerEvent.uniqueID].Contains(readerEvent.idHash))
                        numAccessed[date.ToString("yyyy-MM-dd")][readerEvent.uniqueID].Add(readerEvent.idHash);
                }
                else
                {
                    numAccessed[date.ToString("yyyy-MM-dd")].Add(readerEvent.uniqueID, new List<string>() { readerEvent.idHash });
                }
            }
            else
            {
                numAccessed.Add(date.ToString("yyyy-MM-dd"), new Dictionary<string, List<string>>());
                numAccessed[date.ToString("yyyy-MM-dd")].Add(readerEvent.uniqueID, new List<string>() { readerEvent.idHash });
            }
        }

        //string 1 = day of week, string 2 = door, int = number of unique idHashs
        Dictionary<string, Dictionary<string, double>> averagedNumAccess = new Dictionary<string, Dictionary<string, double>>();

        //string 1 = day of week, string 2 = times that day has occured
        Dictionary<string, int> numDays = new Dictionary<string, int>();

        foreach(var entry in numAccessed)
        {
            var date = DateTime.Parse(entry.Key);
            if(numDays.ContainsKey(date.DayOfWeek.ToString()))
            {
                numDays[date.DayOfWeek.ToString()]++;
            } else
            {
                numDays.Add(date.DayOfWeek.ToString(), 1);
            }

            if(averagedNumAccess.ContainsKey(date.DayOfWeek.ToString()))
            {
                foreach(var door in entry.Value)
                {
                    if(averagedNumAccess[date.DayOfWeek.ToString()].ContainsKey(door.Key))
                    {
                        averagedNumAccess[date.DayOfWeek.ToString()][door.Key] += Convert.ToDouble(door.Value.Count);
                    }
                    else
                    {
                        averagedNumAccess[date.DayOfWeek.ToString()].Add(door.Key, Convert.ToDouble(door.Value.Count));
                    }
                }
            } else
            {
                averagedNumAccess.Add(date.DayOfWeek.ToString(), new Dictionary<string, double>());
                foreach (var door in entry.Value)
                {
                    averagedNumAccess[date.DayOfWeek.ToString()].Add(door.Key, Convert.ToDouble(door.Value.Count));
                }
            }
        }

        UDEX = new List<string> { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
    }

   void LongestInactivityTimes()
    {

    }

    void AbnormalEntries()
    {

    }

    public class ReaderEvent
    {
        public string eventTime { get; set; }
        public string location { get; set; }
        public string readerDesc { get; set; }
        public string idHash { get; set; }
        public string uniqueID { get; set; }

        public ReaderEvent(string eventTime, string location, string readerDesc, string idHash, string devID, string machine)
        {
            this.eventTime = eventTime;
            this.location = location;
            this.readerDesc = readerDesc;
            this.idHash = idHash;
            uniqueID = string.Concat(devID,machine);
        }
    }
}